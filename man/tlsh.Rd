% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsl.R
\name{tlsh}
\alias{tlsh}
\title{Create a new \code{tlsh} object}
\usage{
tlsh(content = NULL)
}
\arguments{
\item{content}{Can be a URL, path, lenth 1+ character vector or raw vector.
See \code{Details} for more info}
}
\value{
\code{tlsh} object
}
\description{
An alternative to the simple interface when you need more control over
the hashing (e.g. reading in a large file chunk-by-chunk). The mini-DSL
is created with the concept of piping (i.e. use of \code{\%>\%}) in mind.
}
\details{
At a minimum, a new, empty \code{tlsh} object will be created and returned. By
specifying \code{content}, the caller can pre-populate the hash with content.
Tests will performed on \code{content} and the behaviour will be different depending on
what is passed in:
\itemize{
\item Single element character vectors will be checked to see if they are a URL
or a path to a valid, reachable file. If either the URL or file case matches
the content will be read in and added to the hash object. Larger files
will (eventually) be chunked in via the \emph{update} ability of \code{tlsh} objects.
\item Single element character vectors that are not URLs or files will be
added in a text content provided they are >50 characters (a limitation of
\code{tlsh} objects and the underlying algorithm).
\item Length 1+ character vectors will have each element added in via the \code{update}
mechanism noted above.
\item A raw vector will be added as would normally be through other DSL methods
}
}
